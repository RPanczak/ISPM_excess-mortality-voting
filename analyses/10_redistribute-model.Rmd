---
title: "Supplementary text S1"
subtitle: "Local correlates of municipality-level excess mortality in Switzerland in 2020"
author: "Julien Riou, Radoslaw Panczak, Garyfallos Konstantinoudis, Matthias Egger"
date: "`r Sys.Date()`"
output:
  rmdformats::robobook:
    code_folding: hide
    self_contained: true
    highlight: pygments
editor_options: 
  chunk_output_type: console
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../docs")})
---

```{r setup, include = FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
set.seed(12345)
options(scipen = 999,max.print=2500,width=100)
library(pacman)
p_load(tidyverse, magrittr, skimr, scales,
       sf, tmap,
       viridis,
       INLA,
       ggiraph)
theme_set(theme_bw())
```

```{r conflicts, include = FALSE}
source("R/helper_functions.R")
tidyverse::tidyverse_conflicts()
conflicted::conflict_scout()
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(cache = FALSE,prompt = FALSE, tidy = FALSE, comment = NA, message = FALSE, warning = FALSE)
knitr::opts_knit$set(width = 75)
```

# Data

```{r data, include = FALSE}
# Shapes
kt = read_rds("data/BfS/kt.Rds")
tg3o = read_rds("data/BfS/tg3o.Rds")
shap = list(kt=kt,tg3o=tg3o)
# Downscaled data
exp_deaths_2020_year = read_rds("results/exp_deaths_2020_year.Rds") %>% 
  select(-cant_exp_deaths, -cant_observed, -p)  %>% 
  mutate(id_kt = as.integer(as.factor(canton))) 
# Removing communities without voting data.  
exp_deaths_2020_year = exp_deaths_2020_year %>% 
  filter(!is.na(vote_yes_nov_cat)) %>% 
  filter(!is.na(vote_yes_jun_cat)) 
# Removing `<40` age group.  
exp_deaths_2020_year = exp_deaths_2020_year %>% 
  filter(age_group != "<40") 
# Create special variables for inla.
exp_deaths_2020_year = exp_deaths_2020_year %>% 
  mutate(id_space=as.numeric(as.factor(GMDNR)),
         id_space2=id_space,
         sex_fem=ifelse(sex=="Female",1,0),
         age_num=as.numeric(as.factor(age_group)),
         age_60s=ifelse(age_group=="60-69",1,0),
         age_70s=ifelse(age_group=="70-79",1,0),
         age_80s=ifelse(age_group=="80+",1,0),
         type_urban=ifelse(r_urban1=="Urban",1,0),
         type_periurban=ifelse(r_urban1=="Periurban",1,0),
         type_rural=ifelse(r_urban1=="Rural",1,0),
         density_high=ifelse(r_urban2=="Dense",1,0),
         density_low=ifelse(r_urban2=="Low",1,0),
         sep5=ifelse(median_ssep3_q=="5th - highest",1,0),
         sep4=ifelse(median_ssep3_q=="4th",1,0),
         sep3=ifelse(median_ssep3_q=="3rd quintile",1,0),
         sep2=ifelse(median_ssep3_q=="2nd",1,0),
         sep1=ifelse(median_ssep3_q=="1st - lowest",1,0),
         lang_fr=ifelse(r_lang=="French",1,0),
         lang_it=ifelse(r_lang=="Italian",1,0),
         vote_nov_q5=ifelse(vote_yes_nov_cat==5,1,0),
         vote_nov_q4=ifelse(vote_yes_nov_cat==4,1,0),
         vote_nov_q3=ifelse(vote_yes_nov_cat==3,1,0),
         vote_nov_q2=ifelse(vote_yes_nov_cat==2,1,0),
         vote_nov_q1=ifelse(vote_yes_nov_cat==1,1,0),
         vote_jun_q5=ifelse(vote_yes_jun_cat==5,1,0),
         vote_jun_q4=ifelse(vote_yes_jun_cat==4,1,0),
         vote_jun_q3=ifelse(vote_yes_jun_cat==3,1,0),
         vote_jun_q2=ifelse(vote_yes_jun_cat==2,1,0),
         vote_jun_q1=ifelse(vote_yes_jun_cat==1,1,0),
         E=log(ifelse(munici_exp_deaths==0,1e-4,munici_exp_deaths)))
```


```{r}
summary_table(exp_deaths_2020_year) %>% 
  flextable::flextable()
```

```{r}
correlogram(exp_deaths_2020_year)
```


# Models of observed and expected deaths by municipality

## Step 1: iterative model development

To facilitate model development we only use the median excess mortality by municipality, age group and sex in 2020. 

```{r}
data1 = exp_deaths_2020_year %>% 
  group_by(canton, GMDNR, GMDNAME, age_group, id_space, sex, munici_observed, munici_pop,
           density_high, density_low, across(starts_with("sep")), border, lang_fr, lang_it,
           across(starts_with("vote")),type_urban,type_rural,type_periurban) %>% 
  summarise(munici_exp_deaths=median(munici_exp_deaths),
            munici_excess=median(munici_excess)) %>% 
  mutate(E=log(ifelse(munici_exp_deaths==0,1e-4,munici_exp_deaths))) %>% 
  ungroup()
rm(exp_deaths_2020_year)
# gc()
```

```{r}
hyper.iid = list(theta = list(prior = "pc.prec", param = c(1, 0.01)))
hyper.bym2 = list(theta1 = list("PCprior", c(1, 0.01)), 
                  theta2 = list("PCprior", c(0.5, 0.5)))
threads = parallel::detectCores()
```

### Model 1.0: no covariates

We use a model structure similar to Poisson regression, where $O_{t,i,j,k}$, the number of observed deaths during week $t$ in municipality $i$, age group $j$ and sex group $k$, depends on the number of expected deaths $E_{t,i,j,k}$ based on historical data and a linear predictor $\lambda$. 

$$
O_i \sim \text{Poisson}(E_i \times \exp(\lambda)) \\
$$
At start, the linear predictor $\lambda$ only includes one intercept parameter $\alpha$, so that the estimate of $\exp(\alpha)$ can be interpreted as an average relative excess mortality for 2020. By adding covariates to $\lambda$, we aim to disentangle the various factors that are associated with excess mortality at the local level.

We implement this model in R-INLA, a Bayesian inference package that is especially adapted to spatial data. This is achieved in practice by including $\log (E_{i,j,k})$ as an offset (although an alternative formulation based on the E argument exists). During model development, we compare different model versions based on the WAIC (lower values imply a better fit). 

```{r}
model1.0 = INLA::inla(munici_observed ~ 1 + offset(E),
                      data = data1,
                      family = "Poisson",
                      control.compute = list(config = TRUE, waic = TRUE),
                      quantiles = c(0.025, 0.5, 0.975),
                      num.threads = threads,
                      safe = TRUE)
summary(model1.0)
exp(model1.0$summary.fixed)[c(1,3,5)]
sum(data1$munici_observed)/sum(data1$munici_exp_deaths)
```

As a sanity check, we find a relative excess mortality of 38% for 2020, that is coherent with a simple calculation (74,776 observed / 54,046 expected = 1.38). Remember that we excluded the age group 0-40, which explains why this is higher than numbers reported for Switzerland, generally around 10% for 2020. We can also look at the model fit and at the residuals. Obviously the model fit is not good here, as this basic model assumes a unique relative excess mortality for all areas, sexes and age groups.

```{r echo=FALSE}
modelfit1(model1.0,data1,nf=20)
```

### Model 1.1: age and sex

We hypothesize that excess mortality affected different age and sex groups differently. We thus add the age group, the sex and the interaction of the two as covariates.

```{r}
model1.1 = INLA::inla(munici_observed ~ - 1 + offset(E) +
                        sex:age_group,
                      data = data1,
                      family = "Poisson",
                      control.compute = list(config = TRUE, waic = TRUE),
                      quantiles = c(0.025, 0.5, 0.975),
                      num.threads = threads,
                      safe = TRUE)
summary(model1.1)
exp(model1.1$summary.fixed)[c(1,3,5)]
model1.1$waic$waic - model1.0$waic$waic 
```

As expected, the relative excess mortality varies a lot across age and sex groups. It's very small in females aged 40-59 and 60-69 (in fact the data is compatible with no excess in both cases). It increases in females aged 70-79, and even more so aged 80+. It's comparatively higher in males below 80, but somewhat surprisingly lower in males in age group 80+.
We observe an improvement of the model fit, not easy to spot on the plot because of the large number of points, but made clear by the large decrease in WAIC.

```{r echo=FALSE}
modelfit1(model1.1,data1,nf=20)
```

### Model 1.2: spatial variability

We now account for spatial variability, first in a simple way using an i.i.d. random effect, so that all municipalities can vary independently from each other around a global average.

```{r}
model1.2 = INLA::inla(munici_observed ~ - 1 + offset(E) +
                        sex:age_group +
                        f(id_space, model = "iid"),
                      data = data1,
                      family = "Poisson",
                      control.compute = list(config = TRUE, waic = TRUE),
                      quantiles = c(0.025, 0.5, 0.975),
                      num.threads = threads,
                      safe = TRUE)
summary(model1.2)
exp(model1.2$summary.fixed)[c(1,3,5)]
model1.2$waic$waic - model1.1$waic$waic 
```

The age and sex effect remains similar, but the model fit as measured by the WAIC is improved now that we account for local differences. We can observe this municipality effect, that applies in all age and sex groups of the municipality in exactly the same way.

```{r echo=FALSE}
map_munic(model1.2,data1,shap,interactive=TRUE)
```

```{r echo=FALSE}
rank_munic(model1.2,data1,nf=50)
```

We find noisy estimates in some places, suggesting issues related to small area estimation. One solution is to partially pool information between municipalities that are geographically linked.

### Model 1.3: structured spatial variability

We still focus on spatial variability, but now the municipalities are no longer independent: we account for the correlation between neighboring municipalities with a BYM model. This will allow us to differentiate between what can be attributed to a municipality in particular, and what can be attributed to regional effects (like a COVID wave).

```{r}
model1.3 = INLA::inla(munici_observed ~ - 1 + offset(E) +
                        sex:age_group +
                        f(id_space, model = "bym2", graph = "data/nb/gg_wm_q.adj", scale.model = TRUE, 
                          hyper = hyper.bym2, constr=TRUE),
                      data = data1,
                      family = "Poisson",
                      control.compute = list(config = TRUE, waic = TRUE),
                      quantiles = c(0.025, 0.5, 0.975),
                      num.threads = threads,
                      safe = TRUE)
summary(model1.3)
exp(model1.3$summary.fixed)[c(1,3,5)]
model1.3$waic$waic - model1.2$waic$waic 
```

We see that the structure accounts for about half of the spatial variability (Phi estimated to 0.5). This addition also improves the model fit as measured by the WAIC.

```{r echo=FALSE}
map_munic(model1.3,data1,shap,interactive=TRUE)
```

```{r echo=FALSE}
rank_munic(model1.3,data1,nf=50)
```

We observe that many of the municipalities with higher relative excess mortality are in the western and southern parts, the ones that were hit first by COVID-19 in 2020. We also observe areas with higher excess in the North and Northeastern parts. These largely correspond to areas that were hit the most during the first and the second COVID-19 waves of spring and fall 2020 (REF Konstantinoudis et al NatCom 2022). 

### Model 1.4: local characteristics

Having accounted for regional variability (arguably caused by COVID-19 waves of different timings and scales), we move on to explore the effect of local characteristics at the municipality level.

#### Rural/urban

The Federal Statistical Office classifies Swiss municipalities in 3 classes: urban, rural or intermediate (https://www.bfs.admin.ch/bfs/en/home/statistics/territory-environment/nomenclatures/gemtyp.html). We add this covariate to the model taking the "intermediate" category as the reference, and including an interaction with age.

```{r}
model1.4a = INLA::inla(munici_observed ~ - 1 + offset(E) +
                         sex:age_group +
                         f(id_space, model = "bym2", graph = "data/nb/gg_wm_q.adj", scale.model = TRUE, 
                           hyper = hyper.bym2, constr=TRUE) +
                         age_group:type_periurban + age_group:type_urban,
                       data = data1,
                       family = "Poisson",
                       control.compute = list(config = TRUE, waic = TRUE),
                       quantiles = c(0.025, 0.5, 0.975),
                       num.threads = threads,
                       safe = TRUE)
summary(model1.4a)
exp(model1.4a$summary.fixed)[c(1,3,5)]
model1.4a$waic$waic - model1.3$waic$waic 
```

```{r}
drivers_plot_age(model1.4a,data1) 
```

```{r echo=FALSE}
map_munic(model1.4a,data1,shap,interactive=TRUE)
```

```{r echo=FALSE}
rank_munic(model1.4a,data1,nf=50)
```

Results are not conclusive, but rural municipalities appear to have a slightly higher excess mortality than municipalities classified as intermediate or urban.

#### Socio-economic position

The Swiss neighbourhood index of socio-economic position provides an estimate of socio-economic position (SEP) based on census data for 1.5 million buildings [@panczak2023swiss]. We consider the median index of each municipality, then group municipalities in quintiles before adding to the model (reference is 3rd quintile). Again, we consider the interaction with age.

```{r}
model1.4b = INLA::inla(munici_observed ~ - 1 + offset(E) +
                         sex:age_group +
                         f(id_space, model = "bym2", graph = "data/nb/gg_wm_q.adj", scale.model = TRUE, 
                           hyper = hyper.bym2, constr=TRUE) +
                         age_group:sep1 + age_group:sep2 + age_group:sep3 + age_group:sep4,
                       data = data1,
                       family = "Poisson",
                       control.compute = list(config = TRUE, waic = TRUE),
                       quantiles = c(0.025, 0.5, 0.975),
                       num.threads = threads,
                       safe = TRUE)
summary(model1.4b)
exp(model1.4b$summary.fixed)[c(1,3,5)]
model1.4b$waic$waic - model1.3$waic$waic 
```

```{r}
drivers_plot_age(model1.4b,data1)
```

```{r echo=FALSE}
map_munic(model1.4b,data1,shap,interactive=TRUE)
```

A gradient appears clearly, but high uncertainty remains, so that we can conclude that municipalities of lowest median SEP (1st quintile) had a higher relative excess mortality in 2020 compared to municipalities of highest median SEP (5th quintile). As in other works, we observe that the gradient associated with SEP is less steep for older groups. 

#### Borders

We now consider whether the municipality shares a border with another country.

```{r}
model1.4c = INLA::inla(munici_observed ~ - 1 + offset(E) +
                         sex:age_group +
                         f(id_space, model = "bym2", graph = "data/nb/gg_wm_q.adj", scale.model = TRUE, 
                           hyper = hyper.bym2, constr=TRUE) +
                         age_group:border,
                       data = data1,
                       family = "Poisson",
                       control.compute = list(config = TRUE, waic = TRUE),
                       quantiles = c(0.025, 0.5, 0.975),
                       num.threads = threads,
                       safe = TRUE)
summary(model1.4c)
exp(model1.4c$summary.fixed)[c(1,3,5)]
model1.4c$waic$waic - model1.3$waic$waic 
```

```{r}
drivers_plot_age(model1.4c,data1)
```

```{r echo=FALSE}
map_munic(model1.4c,data1,shap,interactive=TRUE)
```

We observe a tendency towards higher relative excess mortality in municipalities sharing a border with another country. However, this indicator is not entirely satisfying, as the level of connection with other countries is more of interest than just sharing a border.

#### Language

Most Swiss municipalities have one official language: German, French or Italian. A few municipalities have several official languages, but given the relatively low numbers, we consider only the majority language. The difficulty is the colinearity between language regions and the first COVID-19 wave of 2020, that primarily affected Ticino (Italian) and Southwestern Switzerland (French), mostly because of how the initial global spread of COVID-19 occurred (with large early epidemics in Italy and then France). These effects are much larger than any effect that could be attributed to cultural differences between language regions, so it is quite difficult to estimate the latter. We still attempt to do so by adding the language of each municipality (reference is German) to our model.

```{r}
model1.4d = INLA::inla(munici_observed ~ - 1 + offset(E) +
                         sex:age_group +
                         f(id_space, model = "bym2", graph = "data/nb/gg_wm_q.adj", scale.model = TRUE, 
                           hyper = hyper.bym2, constr=TRUE) +
                         age_group:lang_fr + age_group:lang_it,
                       data = data1,
                       family = "Poisson",
                       control.compute = list(config = TRUE, waic = TRUE),
                       quantiles = c(0.025, 0.5, 0.975),
                       num.threads = threads,
                       safe = TRUE)
summary(model1.4d)
exp(model1.4d$summary.fixed)[c(1,3,5)]
model1.4d$waic$waic - model1.3$waic$waic 
```

```{r}
drivers_plot_age(model1.4d,data1) + theme(legend.position=c(.3,.87))
```

```{r echo=FALSE}
map_munic(model1.4d,data1,shap,interactive=TRUE)
```

At first sight, we may thing that there is a large effect of language region on excess mortality, with around 5-15% more deaths than expected in French-speaking municipalities and 15-30% more in Italian-speaking municipalities compared to German. However, as expected this association is likely confounded by the regional variability associated with COVID-19 waves in 2020. Indeed, if we now look at the geographically-structured municipality effect for this model, which can be interpreted as residual effects, we see that the higher excess in South and Southwestern Switzerland is now more evenly distributed (captured by the language effect), while French-speaking regions that were comparatively less impacted during the first wave (such as Neuchâtel and Jura) now have a negative municipality effect to compensate. These nonsensical results highlight the difficulty to estimate the effect of language regions. For this reason, in the following we rely upon observing the residual municipality effects to draw conclusion about the association with language rather than using the language as a fixed effect, as shown in the next map based on model 1.3.

```{r echo=FALSE}
map_munic_lang(model1.3,data1,shap,interactive=TRUE)
```

We can make two observations on this last map. First, French-speaking and Italian-speaking municipalities were not systematically more affected than German-speaking, with notable exceptions in the French-speaking area around Neuchâtel and in Italian-speaking municipalities of canton Graubunden. Second, there is a clear separation between the French-speaking and German-speaking municipalities around canton Fribourg, suggesting lower levels of connectivity between these communities.

#### Referendums on COVID-19 measures

We now focus on results from two referendums about COVID-19 control measures held in June and November 2020. The point here is not to look at causality one way or the other, as we look at overall excess for 2020, and the voting took place at two separated points. A preliminary analysis has reported a negative association between the proportion of "yes" vote at the November referendum at the cantonal level and 7-day incidence on December 7, 2021 (https://smw.ch/index.php/smw/announcement/view/50). We classify municipalities according to the proportion of "yes" vote (expressing support of government-issued measures aimed at controlling COVID-19) at each vote, in quintiles (taking the 5th quintile - highest support - as a reference).


```{r}
model1.4e = INLA::inla(munici_observed ~ - 1 + offset(E) +
                         sex:age_group +
                         f(id_space, model = "bym2", graph = "data/nb/gg_wm_q.adj", scale.model = TRUE, 
                           hyper = hyper.bym2, constr=TRUE) +
                         age_group:vote_jun_q1 + age_group:vote_jun_q2 + age_group:vote_jun_q3 + age_group:vote_jun_q4,
                       data = data1,
                       family = "Poisson",
                       control.compute = list(config = TRUE, waic = TRUE),
                       quantiles = c(0.025, 0.5, 0.975),
                       num.threads = threads,
                       safe = TRUE)
summary(model1.4e)
exp(model1.4e$summary.fixed)[c(1,3,5)]
model1.4e$waic$waic - model1.3$waic$waic 
```

```{r}
drivers_plot_age(model1.4e,data1)
```

```{r echo=FALSE}
map_munic(model1.4e,data1,shap,interactive=TRUE)
```



```{r}
model1.4f = INLA::inla(munici_observed ~ - 1 + offset(E) +
                         sex:age_group +
                         f(id_space, model = "bym2", graph = "data/nb/gg_wm_q.adj", scale.model = TRUE, 
                           hyper = hyper.bym2, constr=TRUE) +
                         age_group:vote_nov_q1 + age_group:vote_nov_q2 + age_group:vote_nov_q3 + age_group:vote_nov_q4,
                       data = data1,
                       family = "Poisson",
                       control.compute = list(config = TRUE, waic = TRUE),
                       quantiles = c(0.025, 0.5, 0.975),
                       num.threads = threads,
                       safe = TRUE)
summary(model1.4f)
exp(model1.4f$summary.fixed)[c(1,3,5)]
model1.4f$waic$waic - model1.3$waic$waic 
```

```{r}
drivers_plot_age(model1.4f,data1)
```

```{r echo=FALSE}
map_munic(model1.4f,data1,shap,interactive=TRUE)
```

In both cases, high uncertainty remains, although it appears that excess mortality in age group 80+ appears to be consistently about 5% higher in municipalities expressing lowest support to control measures (first quantile) in both referendums.

### Multivariable model

We now jointly estimate the effects of interest identified in the univariable analysis: rural or urban status, border, median SEP quintile and results from the COVID-19 referendums (using only the June referendum to limit complexity). 

```{r}
model1.5 = INLA::inla(munici_observed ~ - 1 + offset(E) +
                        sex:age_group +
                        f(id_space, model = "bym2", graph = "data/nb/gg_wm_q.adj", scale.model = TRUE, 
                          hyper = hyper.bym2, constr=TRUE) +
                        age_group:border +
                        age_group:type_periurban + age_group:type_urban +
                        age_group:sep1 + age_group:sep2 + age_group:sep3 + age_group:sep4 +
                        age_group:vote_jun_q1 + age_group:vote_jun_q2 + age_group:vote_jun_q3 + age_group:vote_jun_q4,
                      data = data1,
                      family = "Poisson",
                      control.compute = list(config = TRUE, waic = TRUE),
                      quantiles = c(0.025, 0.5, 0.975),
                      num.threads = threads,
                      safe = TRUE)
summary(model1.5)
exp(model1.5$summary.fixed)[c(1,3,5)]
model1.5$waic$waic - model1.3$waic$waic 
```

```{r}
drivers_plot_age(model1.5,data1)
```

```{r echo=FALSE}
map_munic(model1.5,data1,shap,interactive=TRUE)
```

From this multivariate analysis, it appears that the only consistent association is with the median SEP of the municipality, and is especially marked age groups 40 to 79. There is also some indication that border municipalities and urban areas were associated with comparatively higher excess mortality in 2020, but the uncertainty remains high. Estimates of an association with voting results are faint. There are also some interesting patterns in the residual effects at the level of the municipality (adjusting for all aforementioned covariates), with in particular, expected higher excesses in Ticino and Southwestern Switzerland, a visible language barrier between French-speaking and German-speaking regions, lower excess in the large cities of the German-speaking part (Zurich, Basel, Bern) and in relatively isolated valleys of Graubunden.

```{r}
save(list=ls(pattern="model1."),data1,
     file = "results_inla/local_corr_models.Rdata")
```



## Step 2: multivariate model with full uncertainty propagation

In the previous section we modeled the variation of the median excess mortality over 2020 by municipality. This approach underestimates the uncertainty from two sources, first from the prediction error in the expected mortality at the cantonal level, second from the downscaling to the municipal level. At this stage, we bring back these two sources of uncertainty in the final estimates by repeatedly fitting model 1.5 to 50 different sets of posterior draws of excess mortality by municipality, then combining with equal weights. 

```{r}
model1.5_merg = readRDS("results_inla/model1.5_merg.rds")
summary(model1.5_merg)
```

```{r}
drivers_plot_age(model1.5_merg,data1,compute_cri = TRUE)
```

```{r echo=FALSE}
map_munic(model1.5_merg,data1,shap,interactive=TRUE,compute_cri = TRUE)
```

As expected, this approach leads to a dilution of the observed associations between relative excess mortality and local covariates. We still observe a linear gradient in the association between excess mortality and median SEP at the municipal level in age groups 40 to 79, and a likely association between excess mortality and border municipalities, although in both cases with higher uncertainty. We also observe similar patterns in the residual effects at the level of the municipality, again with higher uncertainty.


