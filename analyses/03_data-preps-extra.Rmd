---
title: "2020 excess mortality & voting patterns in CH"
subtitle: "Ancillary data preparation"
pagetitle: "Excess & voting: ancillary data"
author: "Radek Panczak"
date: "`r Sys.Date()`"
output:
  rmdformats::robobook:
    code_folding: show
    self_contained: true
    highlight: pygments
editor_options: 
  chunk_output_type: console
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../docs") })
---

<!-- ----------------------------------------------------- -->

```{r setup, include = FALSE}
set.seed(12345)
options(scipen = 999)
options(max.print = "75")

# devtools::install_github("politanch/swissdd")

library(pacman)
p_load(haven, readxl,
       tidyverse, magrittr, janitor, scales, lubridate, 
       DT, 
       sf, tmap,
       swissdd)

import::from("sjmisc", "frq")
```

```{r conflicts, include = FALSE}
tidyverse::tidyverse_conflicts()

conflicted::conflict_scout()
```

```{r knit-setup, include = FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

knitr::opts_chunk$set(cache = FALSE,
                      prompt = FALSE,
                      tidy = FALSE,
                      comment = NA,
                      message = FALSE,
                      warning = FALSE)

knitr::opts_knit$set(width = 75)
```

<!-- ----------------------------------------------------- -->

# Population

Data extracted from [`px-x-0103010000_201`](https://www.pxweb.bfs.admin.ch/pxweb/de/px-x-0103010000_201/-/px-x-0103010000_201.px/):

> Ständige und nichtständige Wohnbevölkerung nach institutionellen Gliederungen, Staatsangehörigkeit (Kategorie), Geburtsort, Geschlecht und Altersklasse

Important info from footnotes:

> *Letzte Änderungen: Neuer Datensatz (Jahr 2020)*
> *Stand der Datenbank: Juni 2021*
> *Stichtag: 31. Dezember*
> **Raumbezug: Gemeinden / 18.10.2020**
> *Datenquelle: Statistik der Bevölkerung und der Haushalte STATPOP*
> *Definition der ständigen Wohnbevölkerung*

## Community codes

Community mutations data after `2021-01-01` from BfS are integrated into the data and pops are recalculated using these new codes to match mortality.  

```{r eval=FALSE, include=FALSE}
histcomm_14 <- read_excel("data-raw/BfS/Gemeindestand - Stand vom 01.07.2021.xlsx", 
                          col_types = c("numeric", "text", "skip", 
                                        "skip", "numeric", "text", "text")) %>%
  remove_empty(c("rows", "cols")) %>% clean_names() %>% 
  mutate(datum_der_aufnahme = ymd(datum_der_aufnahme)) %>% 
  filter(datum_der_aufnahme >= ymd("2014-01-01") & 
           datum_der_aufnahme < ymd("2015-01-01")) %>% 
  arrange(datum_der_aufnahme, gemeindename)
```

```{r}
histcomm <- read_rds("data/BfS/histcomm.Rds") %>% 
  filter(datum_der_aufnahme >= ymd("2021-01-01")) %>% 
  select(bfs_gde_num_old, bfs_gde_num_new, gemeindename_new)
```

```{r eval=FALSE, include=FALSE}
datatable(histcomm)
```

Further corrections of municipalities mutations are needed to bring the data to the state of `2022-01-01`.  

## Data preps

Data aggregated to age groups as in deaths dataset. 

```{r}
pop <- read_xlsx("data-raw/BfS/px-x-0103010000_201.xlsx", 
                 col_types = c("numeric", 
                               "skip", "numeric", "text", "skip", 
                               "skip", "skip", "text", "skip", "skip", 
                               "skip", "text", "numeric", "numeric", 
                               "numeric", "numeric", "numeric", 
                               "numeric", "numeric", "numeric", 
                               "numeric", "numeric", "numeric", 
                               "numeric", "numeric", "numeric", 
                               "numeric", "numeric", "numeric", 
                               "numeric", "numeric", "numeric", 
                               "numeric"), 
                 skip = 1) %>%
  remove_empty(c("rows", "cols")) %>% clean_names() %>% 
  rename(year = x1, 
         GMDNR = x2,
         GMDNAME = x3) %>% 
  mutate(sex = if_else(x5 == "Frau", "Female", "Male"),
         nationality = if_else(x4 == "Schweiz", "Swiss", "Foreigner"),
         year = as.integer(year)) %>% 
  select(-x4, -x5) %>% 
  relocate(sex, .after = GMDNAME) %>% 
  relocate(nationality, .after = sex) %>% 
  mutate(GMDNAME = word(GMDNAME, 2, -1)) %>% 
  fill(year, GMDNR, GMDNAME, nationality) %>% 
  mutate(`<40` = x0_4_jahre + x5_9_jahre + x10_14_jahre + x15_19_jahre + 
           x20_24_jahre + x25_29_jahre + x30_34_jahre + x35_39_jahre) %>% 
  select(-x0_4_jahre, -x5_9_jahre, -x10_14_jahre, -x15_19_jahre,  
         -x20_24_jahre, -x25_29_jahre, -x30_34_jahre, -x35_39_jahre) %>% 
  mutate(`40-49` = x40_44_jahre + x45_49_jahre) %>% 
  mutate(`50-59` = x50_54_jahre + x55_59_jahre) %>% 
  mutate(`60-69` = x60_64_jahre + x65_69_jahre) %>% 
  mutate(`70-79` = x70_74_jahre + x75_79_jahre) %>% 
  select(-x40_44_jahre, -x45_49_jahre, -x50_54_jahre, -x55_59_jahre,
         -x60_64_jahre, -x65_69_jahre, -x70_74_jahre, -x75_79_jahre) %>% 
  mutate(`80+` = x80_84_jahre +x85_89_jahre + x90_94_jahre +
           x95_99_jahre + x100_jahre_und_mehr) %>% 
  select(-x80_84_jahre, -x85_89_jahre, -x90_94_jahre,
         -x95_99_jahre, -x100_jahre_und_mehr) %>% 
  pivot_longer(cols = `<40`:`80+`, 
               names_to = "age", values_to = "pop") %>% 
  
  # BfS identified changes
  left_join(histcomm, by = c("GMDNR" = "bfs_gde_num_old")) %>% 
  mutate(GMDNR = if_else(!is.na(bfs_gde_num_new), bfs_gde_num_new, GMDNR),
         GMDNAME = if_else(!is.na(gemeindename_new), gemeindename_new, GMDNAME)) %>% 
  select(-bfs_gde_num_new, -gemeindename_new) %>% 
  
  # Essertes merge
  mutate(GMDNR = if_else(GMDNAME == "Essertes", 5805, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Essertes", "Oron", GMDNAME)) %>% 
  
  # now to reach the state of `2022-01-01`
  mutate(GMDNR = if_else(GMDNAME == "Bad Zurzach", 4324, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Bad Zurzach", "Zurzach", GMDNAME)) %>% 
  mutate(GMDNR = if_else(GMDNAME == "Baldingen", 4324, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Baldingen", "Zurzach", GMDNAME)) %>% 
  mutate(GMDNR = if_else(GMDNAME == "Böbikon", 4324, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Böbikon", "Zurzach", GMDNAME)) %>% 
  mutate(GMDNR = if_else(GMDNAME == "Kaiserstuhl", 4324, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Kaiserstuhl", "Zurzach", GMDNAME)) %>%
  mutate(GMDNR = if_else(GMDNAME == "Rekingen (AG)", 4324, GMDNR)) %>%
  mutate(GMDNAME = if_else(GMDNAME == "Rekingen (AG)", "Zurzach", GMDNAME)) %>%
  mutate(GMDNR = if_else(GMDNAME == "Rietheim", 4324, GMDNR)) %>%
  mutate(GMDNAME = if_else(GMDNAME == "Rietheim", "Zurzach", GMDNAME)) %>%
  mutate(GMDNR = if_else(GMDNAME == "Rümikon", 4324, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Rümikon", "Zurzach", GMDNAME)) %>% 
  mutate(GMDNR = if_else(GMDNAME == "Wislikofen", 4324, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Wislikofen", "Zurzach", GMDNAME)) %>% 
  # Böztal merge
  mutate(GMDNR = if_else(GMDNAME == "Bözen", 4185, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Bözen", "Böztal", GMDNAME)) %>% 
  mutate(GMDNR = if_else(GMDNAME == "Elfingen", 4185, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Elfingen", "Böztal", GMDNAME)) %>% 
  mutate(GMDNR = if_else(GMDNAME == "Effingen", 4185, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Effingen", "Böztal", GMDNAME)) %>% 
  mutate(GMDNR = if_else(GMDNAME == "Hornussen", 4185, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Hornussen", "Böztal", GMDNAME)) %>% 
  # Blonay - Saint-Légier merge
  mutate(GMDNR = if_else(GMDNAME == "Blonay", 5892, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Blonay", "Blonay - Saint-Légier", GMDNAME)) %>% 
  mutate(GMDNR = if_else(GMDNAME == "Saint-Légier-La Chiésaz", 5892, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Saint-Légier-La Chiésaz", "Blonay - Saint-Légier", GMDNAME)) %>% 
  # Murten merge
  mutate(GMDNR = if_else(GMDNAME == "Galmiz", 2275, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Galmiz", "Murten", GMDNAME)) %>% 
  mutate(GMDNR = if_else(GMDNAME == "Gempenach", 2275, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Gempenach", "Murten", GMDNAME)) %>% 
  mutate(GMDNR = if_else(GMDNAME == "Clavaleyres", 2275, GMDNR)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Clavaleyres", "Murten", GMDNAME)) %>% 
  
  # Schwende-Rüte merge
  mutate(GMDNAME = if_else(GMDNAME == "Schwende", "Schwende-Rüte", GMDNAME)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Rüte", "Schwende-Rüte", GMDNAME)) %>% 
  mutate(GMDNR = if_else(GMDNAME == "Schwende-Rüte", 3112, GMDNR)) %>% 
  # Val Mara merge
  mutate(GMDNAME = if_else(GMDNAME == "Melano", "Val Mara", GMDNAME)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Maroggia", "Val Mara", GMDNAME)) %>% 
  mutate(GMDNAME = if_else(GMDNAME == "Rovio", "Val Mara", GMDNAME)) %>%  
  mutate(GMDNR = if_else(GMDNAME == "Val Mara", 5240, GMDNR)) %>%  
  
  group_by(year, GMDNR, GMDNAME, sex, age) %>% 
  summarise(pop = as.integer(sum(pop))) %>% 
  ungroup() %>% 
  arrange(year, GMDNR, sex, age)
```

```{r include=FALSE}
rm(histcomm); gc()
```

Yearly totals (**on 31st Dec**!):  

```{r echo=FALSE}
pop %>% 
  group_by(year) %>% 
  summarise(pop = sum(pop)) %>% 
  mutate(pop = as.character(number(pop, big.mark = ","))) 
```

Age (40 plus!) distributions over years  

```{r echo=FALSE}
pop %>% 
  filter(age != "<40") %>% 
  group_by(year, age, sex) %>% 
  summarise(pop = sum(pop)) %>% 
  ungroup() %>% 
  ggplot(aes(x = age, y = pop, fill = as.factor(year))) + 
  geom_col(position = "dodge") + 
  scale_fill_viridis_d() + 
  xlab("Age group") + ylab("Population count (31st Dec)") +
  theme_minimal()
```

## Predicting 2020 population

```{r eval=FALSE, include=FALSE}
# smallest pops
pop %>% 
  filter(year == 2019) %>% 
  group_by(GMDNR) %>% 
  summarize(pop = sum(pop),
            GMDNAME = first(GMDNAME)) %>% 
  ungroup() %>% 
  arrange(pop)
# arrange(desc(pop))
```

For each age, sex, nationality stratum, for each municipality separately, Poisson model was fitted using the 2014-2019 data; then prediction was made for 2020 & 2021 years. The gist of this operation was to exclude the effect of pandemic from the pop counts in years affected.   

```{r}
pop_ext_poi <- pop %>% 
  filter(year != 2020) %>% 
  # filter(GMDNR == 261 | GMDNR == 389) %>%
  group_by(GMDNR, age, sex) %>% 
  do(glm(pop ~ year, data = ., family = "poisson") %>%
       predict(., newdata = tibble(year = as.integer(2020)), type = "response") %>%
       tibble(year = as.integer(2020), pop_ext_poi = .)) %>% 
  ungroup() %>% 
  mutate(pop_ext_poi = as.integer(round(pop_ext_poi))) %>% 
  arrange(year, GMDNR, sex, age) %>% 
  relocate(year)
```

Summary of values:  

```{r echo=FALSE}
summary(pop_ext_poi$pop_ext_poi)
```

**Note:** *2 NAs!*  

```{r echo=FALSE}
pop %>% 
  filter(GMDNR %in% c(4232) & sex == "Male" & age == "80+")

pop_ext_poi %>% 
  filter(GMDNR %in% c(4232) & sex == "Male" & age == "80+")

pop %>% 
  filter(GMDNR %in% c(389) & sex == "Male" & age == "80+")

pop_ext_poi %>% 
  filter(GMDNR %in% c(389) & sex == "Male" & age == "80+")
```

### Results in large municipality

Results for large municipality are fine. 
Predictions are in red.  

```{r echo=FALSE, warning=FALSE}
pop %>% 
  filter(GMDNR == 261 & (age == "80+" | age == "<40")) %>% 
  bind_rows(pop_ext_poi %>% 
              filter(GMDNR == 261 & (age == "80+" | age == "<40"))) %>% 
  ggplot(aes(x = year)) + 
  geom_point(aes(y = pop)) +
  geom_point(aes(y = pop_ext_poi), color = "red") +
  facet_wrap(age~sex, scales = "free")
```

For small municipality we might end up with sth more wiggly. 

```{r echo=FALSE, warning=FALSE}
pop %>% 
  filter(GMDNR == 389 & (age == "80+" | age == "<40")) %>% 
  bind_rows(pop_ext_poi %>% 
              filter(GMDNR == 389 & (age == "80+" | age == "<40"))) %>% 
  ggplot(aes(x = year)) + 
  geom_point(aes(y = pop)) +
  geom_point(aes(y = pop_ext_poi), color = "red") +
  facet_wrap(age~sex, scales = "free")
```

**Note:** *lack of prediction for 2020 & 2021 for oldest males!*  

There are two municipalities with missing predictions for oldest males:  

```{r echo=FALSE}
(problems <- pop_ext_poi %>% 
   filter(is.na(pop_ext_poi)) %>% 
   select(GMDNR, age, sex) %>% 
   left_join(pop %>% 
               select(GMDNR, GMDNAME) %>% 
               distinct()) %>% 
   distinct())
```

```{r eval=FALSE, include=FALSE}
sapply(pop, function(x) sum(is.na(x)))
sapply(pop_ext_poi, function(x) sum(is.na(x)))

pop %>% 
  bind_rows(pop_ext_poi) %>% 
  filter(GMDNR %in% problems$GMDNR,
         age %in% problems$age,
         sex %in% problems$sex) %>%
  arrange(GMDNR, sex, age, year) %>%
  View()

pop %>% 
  bind_rows(pop_ext_poi) %>% 
  filter(GMDNR %in% problems$GMDNR,
         age %in% problems$age,
         sex %in% problems$sex) %>%
  arrange(GMDNR, sex, age, year) %>%
  View()
```

Population in this strata was replaced by estimates of a simple linear model.  

```{r}
pop_ext_lm <- pop %>%
  filter(year != 2020) %>%
  group_by(GMDNR, age, sex) %>%
  do(lm(pop ~ year, data = .) %>%
       predict(., newdata = tibble(year = as.integer(2020))) %>%
       tibble(year = as.integer(2020), pop_ext_lm = .)) %>%
  ungroup() %>%
  mutate(pop_ext_lm = as.integer(round(pop_ext_lm))) %>%
  arrange(year, GMDNR, sex, age) %>%
  relocate(year)
```

```{r}
pop_complete <- pop %>% 
  
  # extrapolated 2020
  left_join(pop_ext_poi) %>% 
  mutate(pop_ext_poi = if_else(year < 2020, 
                               pop, pop_ext_poi)) %>% 
  
  # replacing 2 poi missings with lm
  left_join(pop_ext_lm) %>% 
  mutate(pop_ext_poi = if_else(year == 2020 & is.na(pop_ext_poi), 
                               pop_ext_lm, pop_ext_poi)) %>% 
  select(-pop_ext_lm) 
```

## Differences in 2020 pops 

Comparing estimates to real values

```{r}
pop_compare <- pop %>% 
  
  filter(year == 2020) %>% 
  select(-year) %>% 
  
  # poi model with 2 missings
  left_join(pop_ext_poi) %>% 
  
  # lm model
  left_join(pop_ext_lm) %>% 
  mutate(pop_ext_poi = if_else(is.na(pop_ext_poi), 
                               pop_ext_lm, pop_ext_poi)) %>% 
  select(-pop_ext_lm) %>% 
  
  # diffs
  mutate(pop_diff = pop_ext_poi - pop,
         perc_diff = (pop_diff / pop_ext_poi) * 100,
         alt = pop * 100) %>% 
  mutate(perc_diff = if_else(pop_diff == 0, 0, perc_diff),
         perc_diff = if_else(pop_ext_poi == 0, alt, perc_diff)) %>% 
  select(-alt)
```

### Differences

```{r}
frq(pop_compare, pop_ext_poi > pop) 
frq(pop_compare, pop_ext_poi < pop) 
frq(pop_compare, pop_ext_poi == pop)
```

```{r}
summary(pop_compare$pop_diff)
summary(pop_compare$perc_diff)
```

### Age group specific diffs

```{r echo=FALSE}
pop_compare %>% 
  filter(age != "<40") %>% 
  ggplot(aes(x = pop_diff, y = perc_diff)) + 
  geom_point(color = "darkorchid", alpha = 0.2) +
  facet_wrap(vars(sex, age), scales = "free") + 
  theme_light()
```

### Municipality specific diffs

```{r}
pop_compare_agg <- pop_compare %>% 
  filter(age != "<40") %>% 
  group_by(GMDNR) %>% 
  summarise(pop = sum(pop),
            pop_ext_poi = sum(pop_ext_poi)) %>% 
  ungroup() %>% 
  mutate(pop_diff = pop_ext_poi - pop,
         perc_diff = (pop_diff / pop_ext_poi) * 100,
         alt = pop * 100) %>% 
  mutate(perc_diff = if_else(pop_diff == 0, 0, perc_diff),
         perc_diff = if_else(pop_ext_poi == 0, alt, perc_diff)) %>% 
  select(-alt)

gg_centr <- read_rds("data/BfS/gg.Rds") %>% 
  select(GMDNR, GMDNAME) %>% 
  st_centroid() %>% 
  left_join(pop_compare_agg)
```

```{r}
summary(pop_compare_agg$pop_diff)
summary(pop_compare_agg$perc_diff)
```

```{r echo=FALSE}
ggplot(pop_compare_agg, aes(x = pop_diff, y = perc_diff)) + 
  geom_point(color = "darkorchid", alpha = 0.2) +
  theme_light()
```

```{r echo=FALSE}
tmap_mode("view")

tm_shape(gg_centr) +
  tm_bubbles(size = "pop_diff", col = "perc_diff",
             style = "fixed", breaks = c(-20, -10, -5, -1, 0, 1, 5, 10, 32))
```

## Getting mid-year pops

For each age, sex, nationality stratum, for each municipality separately, simple mean of the two years of data is used to estimate the middle point. In such case we use, for instance data from 31st Dec 2014 and 31st Dec 2015 to estimate pop mid-2015.   

```{r}
for (i in 2014:2019){
  
  result <- pop_complete %>% 
    filter(year >= i & year <= i + 1) %>% 
    # filter(GMDNR == 261 | GMDNR == 389) %>%
    group_by(GMDNR, age, sex) %>% 
    summarise(pop_mid_poi = mean(pop_ext_poi)) %>% 
    ungroup() %>% 
    mutate(year = as.integer(i + 1),
           pop_mid_poi = as.integer(round(pop_mid_poi))) %>% 
    arrange(GMDNR, sex, age) %>% 
    relocate(year)
  
  if (i == 2014) {
    pop_mid_poi <- result
  } else {
    pop_mid_poi <- bind_rows(pop_mid_poi, result)
  }
  
}
```

```{r include=FALSE}
table(pop_complete$year)
table(pop_mid_poi$year)

rm(i, result, pop, pop_ext_poi, pop_ext_lm); gc()
```

### Large municipality 

Again, results for large municipality are fine:  

```{r echo=FALSE, warning=FALSE}
pop_complete %>% 
  filter(GMDNR == 261 & (age == "80+" | age == "<40")) %>% 
  mutate(year = year + 1) %>% 
  bind_rows(pop_mid_poi %>% 
              filter(GMDNR == 261 & (age == "80+" | age == "<40")) %>% 
              mutate(year = year + .5)) %>% 
  ggplot(aes(x = year)) + 
  geom_point(aes(y = pop_ext_poi)) +
  geom_point(aes(y = pop_mid_poi), color = "red") +
  facet_wrap(age~sex, scales = "free")
```

### Small municipality 

Again, for small municipality we might end up with sth more wiggly.  

```{r echo=FALSE, warning=FALSE}
pop_complete %>% 
  filter(GMDNR == 389 & (age == "80+" | age == "<40")) %>% 
  mutate(year = year + 1) %>% 
  bind_rows(pop_mid_poi %>% 
              filter(GMDNR == 389 & (age == "80+" | age == "<40")) %>% 
              mutate(year = year + .5)) %>% 
  ggplot(aes(x = year)) + 
  geom_point(aes(y = pop_ext_poi)) +
  geom_point(aes(y = pop_mid_poi), color = "red") +
  facet_wrap(age~sex, scales = "free")
```

## Deaths <-> pop link

Prepared pop file is merged to deaths dataset prepared in `02.Rmd`.  
**We use file based on place of residence.**  

```{r}
w_deaths_2015_2020_year_pop <- read_rds("data/BfS-closed/monthly_deaths/w_deaths_2015_2020_year.Rds") %>% 
  left_join(pop_mid_poi) 
```

```{r eval=FALSE, include=FALSE}
frq(w_deaths_2015_2020_year_pop, year)
summary(w_deaths_2015_2020_year_pop$pop_mid_poi)
```

## Deaths > pop problem

```{r}
frq(w_deaths_2015_2020_year_pop, observed > pop_mid_poi)
```

```{r}
surplus <- w_deaths_2015_2020_year_pop %>% 
  filter(observed > pop_mid_poi) %>% 
  arrange(GMDNR, year) %>% 
  mutate(difference = pop_mid_poi - observed)
```

There are `r number(nrow(surplus))` strata from `r number(length(unique(surplus$GMDNR)))`  communities where count of deaths is larger than count of pop. The difference is always 1 in plus over pop 0.   

```{r echo=FALSE}
surplus %>% 
  select(-GMDNR, -KTNR, -starts_with("id_"), -border, -starts_with("AR")) %>% 
  datatable()
```

**In all these cases pop was increased by 1 to match the count of deaths!**  

```{r}
w_deaths_2015_2020_year_pop %<>% 
  mutate(pop_mid_poi = if_else(observed > pop_mid_poi, observed, pop_mid_poi))
```

```{r eval=FALSE, include=FALSE}
# missing checks
test <- read_rds("data/BfS-closed/monthly_deaths/w_deaths_2015_2020_year.Rds")

missing1 <- test %>% 
  anti_join(pop_complete) %>% 
  select(GMDNAME) %>% 
  distinct()

missing2 <- pop_complete %>% 
  filter(year > 2014) %>% 
  anti_join(test) %>% 
  select(GMDNAME) %>% 
  distinct()

rm(test, missing1, missing2); gc()
```

```{r include=FALSE}
rm(surplus); gc()

write_rds(pop_complete, "data/BfS/pop_complete.Rds")
write_rds(pop_mid_poi, "data/BfS/pop_mid_poi.Rds")
```

<!-- ----------------------------------------------------- -->

# Cartogram

Using 2019 pop counts (*ignoring age structure*) to derive cartograms to avoid effects of pandemic.  

## Communities  & pops

```{r include=FALSE}
# prepared in 01.Rmd
gg <- read_rds("data/BfS/gg.Rds") %>% select(GMDNR, GMDNAME)
se <- read_rds("data/BfS/se.Rds") %>% select(GMDNR, GMDNAME)
kt <- read_rds("data/BfS/kt.Rds") %>% select(KTNR, KTNAME)

st_gg <- read_rds("data/swisstopo/st_gg.Rds") %>% 
  st_transform(crs = 2056) %>% 
  select(-GEM_TEIL)

carto_data <- 
  gg %>% 
  left_join(
    pop_complete %>% 
      # modelled mid year 2020 can be used too???
      filter(year == 2019) %>% 
      group_by(GMDNR) %>% 
      summarise(pop = sum(pop)) %>% 
      ungroup()
  ) %>% 
  relocate(geometry, .after = last_col())
```

## R solution 1

Using `cartogram` package.  

```{r eval=FALSE}
# takes a while!
carto <- carto_data %>%
  cartogram::cartogram_cont("pop")

write_rds(carto, "data/carto/carto.Rds")

carto_ncont <- carto_data %>% 
  cartogram::cartogram_ncont("pop")

write_rds(carto_ncont, "data/carto/carto_ncont.Rds")

carto_dorling <- carto_data %>% 
  cartogram::cartogram_dorling("pop")

write_rds(carto_dorling, "data/carto/carto_dorling.Rds")
```

<!-- ## R solution 2 -->

<!-- Using `cartogramR` package.   -->

```{r eval=FALSE}
carto_gsm <- carto_data %>%
  cartogramR::cartogramR(count = "pop", method = "gsm")

write_rds(carto_gsm, "data/carto/carto_gsm.Rds")
```

## ScapeToad version

```{r eval=FALSE}
carto_data %>% 
  st_write("data/carto/in_gg.shp", delete_dsn = TRUE)

se %>% 
  select(GMDNR, GMDNAME) %>% 
  st_write("data/carto/in_se.shp", delete_dsn = TRUE)

# java -Xmx1g -jar "C:\Program Files\ScapeToad-v11\ScapeToad.jar"
```

```{r include=FALSE}
# carto <- read_rds("data/carto/carto.Rds")
carto_ncont <- read_rds("data/carto/carto_ncont.Rds")
carto_dorling <- read_rds("data/carto/carto_dorling.Rds")

# carto_gsm <- read_rds("data/carto/carto_gsm.Rds")

# ScapeToad version
carto <- st_read("data/carto/out_gg.shp")
carto_se <- st_read("data/carto/out_se.shp")

tmap_mode("plot")
```

### 'Classic' cartogram  

```{r echo=FALSE, message=FALSE, warning=FALSE}
tm_shape(carto) + 
  tm_polygons("pop", 
              style = "bclust", n = 5,
              palette = "-RdYlGn",
              legend.show = TRUE) +
  tm_shape(carto_se) + 
  tm_polygons("dodgerblue", 
              legend.show = TRUE, border.col = NA, alpha = 0.5) +
  tm_layout(frame = FALSE)
```

### Noncontinuous cartogram  

```{r echo=FALSE, message=FALSE, warning=FALSE}
tm_shape(kt) + 
  tm_borders() + 
  tm_shape(carto_ncont) + 
  tm_fill("pop", 
          style = "bclust", n = 5,
          palette = "-RdYlGn",
          legend.show = TRUE) +
  tm_layout(frame = FALSE)
```

### Dorling carotgram  

```{r echo=FALSE, message=FALSE, warning=FALSE}
tm_shape(carto_dorling) + 
  tm_fill("pop", 
          style = "bclust", n = 5,
          palette = "-RdYlGn",
          legend.show = TRUE) +
  tm_layout(frame = FALSE)
```

```{r include=FALSE}
rm(carto, carto_dorling, carto_ncont, carto_se); gc()
```

<!-- ----------------------------------------------------- -->

# Swiss-SEP

```{r}
sep3 <- read_rds("../SNC_Swiss-SEP2/FINAL/RDS/ssep3_user_geo.Rds") %>%
  select(gisid, ssep3, ssep3_q) %>% 
  st_transform(crs = 2056)
```

Using `r number(nrow(sep3), big.mark = ",")` n'hoods from version 3.0:  

```{r echo=FALSE}
sep3 %>% 
  st_drop_geometry() %>% 
  frq(ssep3_q)
```

This is aggregated to the level of `r scales::number(length(unique(st_gg$GMDNR)), big.mark = ",")` communities from swisstopo.

## STATPOP

```{r}
statpop2019 <- read_delim("data-raw/BfS-closed/STATPOP/statpop2019_220098p.zip", 
                          delim = ";", escape_double = FALSE, 
                          col_types = cols(STATYEAR = col_integer(), 
                                           SEX = col_integer(), 
                                           TYPEOFRESIDENCE = col_integer(), 
                                           POPULATIONTYPE = col_integer(), 
                                           AGE = col_integer(), 
                                           CLASSAGEFIVEYEARS = col_integer(), 
                                           NATIONALITYCATEGORY = col_integer(), 
                                           MAINRESIDENCECATEGORY = col_integer(), 
                                           GEOCOORDE = col_integer(), 
                                           GEOCOORDN = col_integer(), 
                                           INDIC_EGID = col_integer(), 
                                           statdate = col_date(format = "%d/%m/%Y")), 
                          trim_ws = TRUE) %>% 
  remove_empty(c("rows", "cols")) %>% clean_names()  

statpop2019_agg <- statpop2019 %>% 
  rename(egid = federalbuildingid) %>% 
  filter(typeofresidence == 1) %>% 
  filter(populationtype == 1) %>% 
  filter(mainresidencecategory == 1) %>% 
  filter(indic_egid == 1) %>% 
  select(-statyear, -statdate, 
         -typeofresidence, -populationtype, -mainresidencecategory,
         -indic_egid) %>% 
  group_by(egid, geocoorde, geocoordn) %>% 
  summarise(pop = n()) %>% 
  ungroup() %>% 
  st_as_sf(coords = c("geocoorde", "geocoordn"), 
           crs = 2056,
           remove = TRUE)
```

Using data from `STATPOP` **2019**.  

Dataset consists of `r scales::number(nrow(statpop2019), big.mark = ",")` individuals and `r scales::number(nrow(statpop2019_agg), big.mark = ",")` buildings. We selected individuals with type of residence *Hauptwohnsitz*, pop type *Ständige Wohnbevölkerung*, main residency category *Nur ein Hauptwohnsitz* and with valid EGID building ID.  

The nearest building with SSEP was assigned for each of these building. The point dataset was then overlaid with community boundaries and summary measures of pop based index were created and pop level SEP was aggregated by community. 

```{r include=FALSE}
rm(statpop2019); gc()
```

## 'nhood based averages for communities

```{r eval=FALSE}
# # or with full version?
# st_gg <- st_read("data-raw/BfS/ag-b-00.03-875-gg/ggg_2021-LV95/shp/g1g21_01072021.shp",
#           as_tibble = TRUE)

ssep3_gem <- 
  st_join(sep3, 
          st_gg, 
          join = st_intersects) 

# tm_shape(gg) +
#   tm_polygons() +
#   tm_shape(ssep3_gem %>% filter(is.na(GMDNR))) +
#   tm_dots()

ssep3_gem_neigh <- ssep3_gem %>% 
  st_drop_geometry() %>% 
  group_by(GMDNR) %>% 
  summarise(n = n(),
            ssep3_median = median(ssep3)) %>% 
  ungroup() 

ssep3_gem_neigh_geo <- inner_join(gg, ssep3_gem_neigh) %>% 
  filter(!is.na(ssep3_median)) %>% 
  mutate(median_ssep3_q = ntile(ssep3_median, 5)) %>% 
  mutate(median_ssep3_q = factor(median_ssep3_q,
                                 levels = 1:5,
                                 labels = c("1st - lowest", 
                                            "2nd",  
                                            "3rd quintile", 
                                            "4th", 
                                            "5th - highest")))

write_rds(ssep3_gem_neigh_geo, "data/BfS/ssep3_gem_neigh_geo.rds")
```

```{r include=FALSE}
ssep3_gem_neigh_geo <- read_rds("data/BfS/ssep3_gem_neigh_geo.rds")
```

Watch out for small n! Here some examples with communities below 20 n'hoods

```{r echo=FALSE}
ssep3_gem_neigh_geo %>% 
  st_drop_geometry() %>% 
  select(GMDNR, GMDNAME, n) %>% 
  inner_join(st_drop_geometry(st_gg)) %>% 
  select(-GMDNR) %>% 
  filter(n < 20) %>%
  arrange(n) %>% 
  datatable(rownames = FALSE, options = list(dom = 't'))
```

```{r eval=FALSE, include=FALSE}
ssep3_gem_neigh_geo %>%
  filter(n < 20) %>%
  qtm(borders = "red", fill = "red")
```

Final map using median index - bubbles scaled to number of 'nhoods within community.

```{r include=FALSE}
tmap_mode("view")
```

```{r eval=FALSE, include=FALSE}
frq(ssep3_gem_neigh_geo$median_ssep3_q)
```

```{r echo=FALSE}
tm_shape(ssep3_gem_neigh_geo) +
  tm_dots(size = "n", col = "median_ssep3_q", palette = "RdYlGn",
          scale = .5,  shape = 19)
```

## Population based averages for communities

```{r eval=FALSE}
# join to sep3
statpop2019_agg_sep <- st_join(statpop2019_agg, sep3, join = st_nearest_feature)

# # fails for unknown and unsolved reasons
# nearest <- st_nearest_feature(statpop2019_agg, sep3)
# statpop2019_agg_sep$dist3 <- st_distance(statpop2019_agg_sep, sep3[nearest, ], by_element = TRUE)
# rm(nearest, statpop2019_agg); gc()
# summary(statpop2019_agg_sep$dist3)

statpop2019_agg_sep_gem <- 
  st_join(statpop2019_agg_sep, st_gg, join = st_intersects) %>%  
  relocate(egid, gisid, pop,
           ssep3, ssep3_q,
           GMDNR) 

write_rds(statpop2019_agg_sep_gem, "data/BfS-closed/SEP/statpop2019_agg_sep_gem.Rds")
```

```{r include=FALSE}
rm(statpop2019_agg); gc()

statpop2019_agg_sep_gem <- read_rds("data/BfS-closed/SEP/statpop2019_agg_sep_gem.Rds") %>% 
  st_drop_geometry()
```

```{r}
ssep3_gem_pop <- statpop2019_agg_sep_gem %>% 
  select(GMDNR, ssep3, pop) %>% 
  uncount(pop) %>% 
  group_by(GMDNR) %>% 
  summarise(pop = n(),
            ssep3_median = median(ssep3)) %>% 
  ungroup() 

# left_join(gg, ssep3_gem_pop) %>% 
#   filter(is.na(ssep3_median))

ssep3_gem_pop_geo <- 
  left_join(gg, ssep3_gem_pop) %>% 
  mutate(median_ssep3_q = ntile(ssep3_median, 5)) %>% 
  mutate(median_ssep3_q = factor(median_ssep3_q,
                                 levels = 1:5,
                                 labels = c("1st - lowest", 
                                            "2nd",  
                                            "3rd quintile", 
                                            "4th", 
                                            "5th - highest")))

write_rds(ssep3_gem_pop_geo, "data/BfS/ssep3_gem_pop_geo.rds")
```

Final map using median index - bubbles scaled to number of people (STATPOP 2020)  

```{r eval=FALSE, include=FALSE}
frq(ssep3_gem_pop_geo$median_ssep3_q)

frq(st_is_valid(ssep3_gem_pop_geo))
```

```{r eval=FALSE, include=FALSE}
ssep3_gem_pop_geo %>% 
  tm_shape() +
  tm_dots(size = "pop", col = "median_ssep3_q", palette = "RdYlGn",
          scale = .5,  shape = 19)
```

```{r include=FALSE}
rm(ssep3_gem_pop, ssep3_gem_neigh); gc()
```

# Raumgliederungen 

Data from the [app](https://www.agvchapp.bfs.admin.ch/de/typologies/query). State as of `2021-07-01` to match spatial data nicely.  

```{r}
raum <- read_xlsx("data-raw/BfS/Raumgliederungen.xlsx", 
                  skip = 1) %>% 
  remove_empty(c("rows", "cols")) %>% clean_names() %>% 
  filter(! is.na(bfs_gde_nummer)) %>% 
  rename(GMDNR = bfs_gde_nummer,
         GMDNAME = gemeindename,
         KTNAME = kanton,
         BZNR = bezirks_nummer,
         BZNAME = bezirksname) %>% 
  select(GMDNR, GMDNAME, KTNAME, BZNR, BZNAME, 
         stadtische_landliche_gebiete, sprachgebiete,
         urbanisierungsgrad_2011_degurba_eurostat,
         gemeindetypologie_2012_9_typen, gemeindetypologie_2012_25_typen) %>% 
  rename(gemtyp_9 = gemeindetypologie_2012_9_typen,
         gemtyp_25 = gemeindetypologie_2012_25_typen) %>% 
  mutate(gemtyp_9 = as.integer(gemtyp_9),
         gemtyp_25 = as.integer(gemtyp_25)) %>% 
  mutate(
    r_urban1 = case_when(
      stadtische_landliche_gebiete == 1 ~  "Urban",
      stadtische_landliche_gebiete == 2 ~  "Periurban",
      stadtische_landliche_gebiete == 3 ~  "Rural",
      TRUE ~  ""),
    r_urban2 = case_when(
      urbanisierungsgrad_2011_degurba_eurostat == 1 ~  "Dense",
      urbanisierungsgrad_2011_degurba_eurostat == 2 ~  "Medium",
      urbanisierungsgrad_2011_degurba_eurostat == 3 ~  "Low",
      TRUE ~  ""),
    r_lang = case_when(
      sprachgebiete == 1 ~  "German",
      sprachgebiete == 2 ~  "French",
      sprachgebiete == 3 ~  "Italian",
      sprachgebiete == 4 ~  "Romansh",
      TRUE ~  "")
  ) %>% 
  select(-stadtische_landliche_gebiete, -sprachgebiete,
         -urbanisierungsgrad_2011_degurba_eurostat) %>% 
  left_join(read_xlsx("data-raw/BfS/Raumgliederungen.xlsx", 
                      skip = 1, sheet = "CH1+CL_GDET9+2012.1") %>% 
              remove_empty(c("rows", "cols")) %>% clean_names() %>% 
              rename(gemtyp_9 = code,
                     gemtyp_9_lab = label) %>% 
              mutate(gemtyp_9 = as.integer(gemtyp_9))) %>% 
  relocate(gemtyp_9_lab, .after = gemtyp_9) %>% 
  left_join(read_xlsx("data-raw/BfS/Raumgliederungen.xlsx", 
                      skip = 1, sheet = "CH1+CL_GDET25+2012.1") %>% 
              remove_empty(c("rows", "cols")) %>% clean_names() %>% 
              rename(gemtyp_25 = code,
                     gemtyp_25_lab = label) %>% 
              mutate(gemtyp_25 = as.integer(gemtyp_25))) %>% 
  relocate(gemtyp_25_lab, .after = gemtyp_25) 
```

```{r include=FALSE}
stopifnot(nrow(anti_join(raum, gg)) == 0)

gg21_merged <- gg %>% 
  left_join(raum) %>% 
  relocate(geometry, .after = last_col())

tmap_mode("plot")
```

## Urbanization 1 

```{r echo=FALSE}
gg21_merged %<>% 
  mutate(r_urban1 = as_factor(r_urban1)) %>% 
  mutate(r_urban1 = fct_relevel(r_urban1, "Urban", "Periurban"))

frq(gg21_merged$r_urban1)

tm_shape(se, is.master = FALSE) +
  tm_fill(col = "#a7cdf2")  +
  tm_shape(gg21_merged) +
  tm_fill(col = "r_urban1", palette = "-Accent")  +
  tm_shape(kt) +
  tm_borders()  +
  tm_layout(
    title = "Urbanization 2021"
  )
```

## Urbanization 2 

Using [DEGURBA](https://ec.europa.eu/eurostat/web/degree-of-urbanisation/background).  

```{r echo=FALSE}
gg21_merged %<>% 
  mutate(r_urban2 = as_factor(r_urban2)) %>% 
  mutate(r_urban2 = fct_relevel(r_urban2, "Dense", "Medium"))

frq(gg21_merged$r_urban2)

tm_shape(se, is.master = FALSE) +
  tm_fill(col = "#a7cdf2")  +
  tm_shape(gg21_merged) +
  tm_fill(col = "r_urban2", palette = "-Accent")  +
  tm_shape(kt) +
  tm_borders()  +
  tm_layout(
    title = "Urbanization 2021"
  )
```

## Language region

```{r echo=FALSE}
gg21_merged %<>% 
  mutate(r_lang = if_else(r_lang == "Romansh", "German", r_lang)) %>% 
  mutate(r_lang = as_factor(r_lang)) %>% 
  mutate(r_lang = fct_relevel(r_lang, "German", "French"))

frq(gg21_merged$r_lang)

tm_shape(se, is.master = FALSE) +
  tm_fill(col = "#a7cdf2")  +
  tm_shape(gg21_merged) +
  tm_fill(col = "r_lang", palette = "-Accent")  +
  tm_shape(kt) +
  tm_borders()  +
  tm_layout(
    title = "Language region 2021"
  )
```

## Typology of communities - 9

```{r echo=FALSE}
frq(gg21_merged$gemtyp_9_lab)

tm_shape(se, is.master = FALSE) +
  tm_fill(col = "#a7cdf2")  +
  tm_shape(gg21_merged) +
  tm_fill(col = "gemtyp_9_lab", palette = "-Accent")  +
  tm_shape(kt) +
  tm_borders()  +
  tm_layout(
    title = "Typology of communities 2021"
  )
```

## Typology of communities - 25

```{r echo=FALSE}
frq(gg21_merged$gemtyp_25_lab)
# length(unique(gg21_merged$gemtyp_25_lab))

tm_shape(se, is.master = FALSE) +
  tm_fill(col = "gray90")  +
  tm_shape(gg21_merged) +
  tm_fill(col = "gemtyp_25_lab", palette = pals::cols25(n = 25))  +
  tm_shape(kt) +
  tm_borders()  +
  tm_layout(
    title = "Typology of communities 2021",
    legend.show = FALSE
  )

tm_shape(gg21_merged) +
  tm_fill(col = "gemtyp_25_lab", palette = pals::cols25(n = 25))  +
  tm_layout(
    title = "Typology of communities 2021",
    legend.only = TRUE
  )
```

<!-- ----------------------------------------------------- -->

# Voting

Data from `swissdd` [package](https://github.com/politanch/swissdd).    

Linked to municipality boundaries from `2022-01-01`.  

```{r}
st_gg <- read_rds("data/swisstopo/st_gg.Rds")
```

## June vote

> Bundesgesetz vom 25.09.2020 über die gesetzlichen Grundlagen für Verordnungen des Bundesrates zur Bewältigung der Covid-19-Epidemie (Covid-19-Gesetz)

### Data 

```{r}
covid_jun <- get_nationalvotes(votedates = "2021-06-13", 
                               geolevel = "municipality") %>% 
  filter(str_detect(name, "Covid-19")) %>% 
  select(-name, -id)
```

```{r echo=FALSE, include=FALSE}
covid_jun %<>% 
  filter(! str_detect(mun_name, fixed("Ausland"))) %>% 
  filter(! str_detect(mun_name, fixed("tranger"))) %>% 
  mutate(GMDNR = as.numeric(mun_id)) %>% 
  relocate(GMDNR) %>% 
  mutate(vote_yes = ntile(jaStimmenInProzent, 5))
# mutate(vote_yes = Hmisc::cut2(jaStimmenInProzent, g = 5))
```

Dataset consists of `r scales::number(length(unique(covid_jun$mun_id)), big.mark = ",")` communities. Votes from abroad are excluded.  

### Results preview

```{r echo=FALSE}
plot_nationalvotes(votedate = "2021-06-13", 
                   vote_id = 6430, geolevel = "municipality")
```

### Link to municipalities

Using `GMDNR` / `mun_id` for deterministic linkage.  

```{r}
covid_jun_gem <- st_gg %>%  
  left_join(covid_jun %>% 
              select(GMDNR, jaStimmenInProzent)) %>% 
  relocate(geometry, .after = last_col())
```

There are few communities that exist on the map but do not exist in the voting dataset:   

```{r echo=FALSE}
covid_jun_gem %>% 
  st_drop_geometry() %>% 
  filter(is.na(jaStimmenInProzent)) %>% 
  select(GMDNR, GMDNAME)
```

```{r include=FALSE}
write_rds(covid_jun, "data/voting/covid_jun.Rds")
write_rds(covid_jun_gem, "data/voting/covid_jun_gem.Rds")
```

## November vote

> Änderung des Bundesgesetzes über die gesetzlichen Grundlagen für Verordnungen des Bundesrates zur Bewältigung der Covid-19-Epidemie (Covid-19-Gesetz) (Härtefälle, Arbeitslosenversicherung, familienergänzende Kinderbetreuung, Kulturschaffende, Veranstaltungen)  

### Data 

```{r}
covid_nov <- get_nationalvotes(votedates = "2021-11-28", 
                               geolevel = "municipality") %>% 
  filter(str_detect(name, "Covid-19")) %>% 
  select(-name, -id)
```

```{r echo=FALSE, include=FALSE}
covid_nov %<>% 
  filter(! str_detect(mun_name, fixed("Ausland"))) %>% 
  filter(! str_detect(mun_name, fixed("tranger"))) %>% 
  mutate(GMDNR = as.numeric(mun_id)) %>% 
  relocate(GMDNR) %>% 
  mutate(vote_yes = ntile(jaStimmenInProzent, 5))
# mutate(vote_yes = Hmisc::cut2(jaStimmenInProzent, g = 5))
```

Dataset consists of `r scales::number(length(unique(covid_nov$mun_id)), big.mark = ",")` communities. Votes from abroad are excluded.  

### Results preview

```{r echo=FALSE}
plot_nationalvotes(votedate = "2021-11-28", 
                   vote_id = 6500, geolevel = "municipality")
```

### Link to municipalities

Using `GMDNR` / `mun_id` for deterministic linkage.  

```{r}
covid_nov_gem <- st_gg %>%  
  left_join(covid_nov %>% 
              select(GMDNR, jaStimmenInProzent)) %>% 
  mutate(vote_yes = ntile(jaStimmenInProzent, 5)) %>%
  # mutate(vote_yes = Hmisc::cut2(jaStimmenInProzent, g = 5)) %>% 
  relocate(geometry, .after = last_col())
```

Again, there are few communities that exist on the map but do not exist in the voting dataset:  

```{r echo=FALSE}
covid_nov_gem %>% 
  st_drop_geometry() %>% 
  filter(is.na(jaStimmenInProzent)) %>% 
  select(GMDNR, GMDNAME)
```

```{r include=FALSE}
write_rds(covid_nov, "data/voting/covid_nov.Rds")
write_rds(covid_nov_gem, "data/voting/covid_nov_gem.Rds")
```

<!-- ----------------------------------------------------- -->

# Mobility & restrictions

## Google 

Google community mobility [reports](https://www.google.com/covid19/mobility/) from `COVID19` [package](https://kjhealy.github.io/covmobility/index.html).  

```{r include=FALSE}
p_load(COVID19)
```

```{r}
gmr <- covid19(country = "CHE", level = 2, 
               start = "2020-01-01",
               end = "2020-12-31",
               gmr = TRUE, verbose = FALSE) %>% 
  select(-administrative_area_level, 
         -administrative_area_level_1,
         -administrative_area_level_2,
         -administrative_area_level_3,
         -iso_numeric, -iso_currency,
         - iso_alpha_2, -iso_alpha_3, 
         - latitude, -longitude, -population, 
         - key_google_mobility, -key_apple_mobility, -key_jhu_csse, -key_nuts, -key_gadm, 
         -(confirmed:vent)) %>% 
  rename(KTNAME = key_local) %>% 
  relocate(id, date, KTNAME)
```

```{r eval=FALSE, include=FALSE}
summary(gmr$date)
```

```{r include=FALSE}
p_unload(COVID19)
```

Data structure for example of 2020 data:  

```{r echo=FALSE}
skimr::skim(gmr)
```

Note: description of variables is described [here](https://covid19datahub.io/articles/docs.html).  

Example of workplace data for canton BE  

```{r echo=FALSE}
gmr %>% 
  filter(KTNAME == "BE") %>% 
  ggplot(aes(x = date, 
             y = workplaces_percent_change_from_baseline, 
             group = KTNAME)) + 
  geom_line(color = "darkorchid") + 
  theme_minimal()
```

```{r eval=FALSE, include=FALSE}
ggplot(gmr, aes(x = date, 
                y = workplaces_percent_change_from_baseline, 
                color = KTNAME,
                group = KTNAME)) + 
  geom_line() + 
  theme_minimal()
```

## Apple 

Apple's (*discontinued*) [Mobility Trend Reports](https://covid19.apple.com/mobility/) from `covmobility` [package](https://kjhealy.github.io/covmobility/index.html).  

```{r include=FALSE}
p_load(covmobility)
```

```{r}
data(apple_mobility)

apple_mobility = apple_mobility %>% 
  filter(country == "Switzerland") %>% 
  filter(date <= ymd("2020-12-31")) %>% 
  filter(geo_type == "sub-region") %>% 
  select(-geo_type, -country, - alternative_name, -sub_region)
```

```{r include=FALSE}
p_unload(covmobility)
```

```{r eval=FALSE, include=FALSE}
frq(apple_mobility, region)
length(unique(apple_mobility$region))

summary(apple_mobility$date)
```

Simpler dataset with a 0-Inf score for each day and canton across three trasport modes.  

```{r echo=FALSE}
frq(apple_mobility, transportation_type)
summary(apple_mobility$score)
```

```{r eval=FALSE, include=FALSE}
# cities possible too

data(apple_mobility)

frq(apple_mobility, geo_type)

apple_mobility_city = apple_mobility %>% 
  filter(country == "Switzerland") %>% 
  filter(date <= ymd("2020-12-31")) %>% 
  select(-country, - alternative_name) %>% 
  filter(geo_type == "city") %>% 
  select(-geo_type)
```

Example of data for canton BE  

```{r echo=FALSE}
apple_mobility %>% 
  filter(region == "Canton of Bern") %>% 
  ggplot(aes(x = date, 
             y = score, 
             color = transportation_type,
             group = region)) + 
  geom_line() + 
  theme_minimal()
```

```{r echo=FALSE}
# https://kjhealy.github.io/covmobility/articles/covmobility.html

data = apple_mobility %>%
  # most data is for driving
  filter(transportation_type == "driving") %>% 
  # two cantons with no data?
  filter(! region %in% c("Canton of Appenzell Innerrhoden", "Canton of Uri")) %>%
  mutate(over_under = score < 100, 
         score = score - 100) 

vec_brks <- c(-50, 0, 50)
vec_labs <- vec_brks + 100

p_load(ggforce)

ggplot(data,
       mapping = aes(x = date, y = score, 
                     group = region, color = over_under)) + 
  geom_hline(yintercept = 0, color = "gray40") + 
  geom_col() + 
  scale_y_continuous(breaks = vec_brks, labels = vec_labs) + 
  scale_color_manual(values = c("firebrick", "steelblue")) +
  facet_wrap(~ region, nrow = 4, ncol = 6) + 
  guides(color = "none") + 
  labs(x = "Date", 
       y = "Relative Mobility", 
       title = "Relative Trends in Apple Maps Usage for Driving, Swiss Cantons", 
       subtitle = "Data are indexed to 100 for each city's usage on January 13th 2020", 
       caption = "Data: Apple.") + 
  theme_minimal()
```

Note: *Appenzell Innerrhoden* & *Uri* have zero data!  

```{r include=FALSE}
p_unload(covmobility, ggforce)
```

<!-- ----------------------------------------------------- -->

# Final link & save 

```{r}
w_deaths_2015_2020_year_fin <- w_deaths_2015_2020_year_pop %>% 
  left_join(ssep3_gem_pop_geo %>% 
              st_drop_geometry() %>% 
              select(-pop)) %>% 
  left_join(gg21_merged %>% 
              st_drop_geometry() %>% 
              select(-GMDNAME, -KTNAME, -BZNR, -BZNAME)
  )

write_rds(w_deaths_2015_2020_year_fin, "data/BfS-closed/monthly_deaths/w_deaths_2015_2020_year_fin.Rds")
```

```{r eval=FALSE, include=FALSE}
# unlink("data/BfS-closed/w_deaths_2015_2021_year.Rds")
```
